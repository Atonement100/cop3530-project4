//
//  main.cpp
//  mitra
//
//  Created by Kniel,Karl E on 4/18/16.
//  Copyright Â© 2016 Kniel,Karl E. All rights reserved.
//

#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>
#include <algorithm>

#define infinity 99999999

using namespace std;

// method to calculate levenshtein distance of two strings
int incantations(string charm1, string charm2)
{
    // variables for string lengths
    long length1, length2;
    
    // make sure charm 1 is the larger charm
    if (charm1.size() > charm2.size())
    {
        length1 = charm1.size();
        length2 = charm2.size();
    }
    // else switch the charms for calculation purposes
    else
    {
        length1 = charm2.size();
        length2 = charm1.size();
        string temp = charm2;
        charm2 = charm1;
        charm1 = temp;
    }
    
    
    // create pointer to an array of size of the shorter charm
    int * distance = new int[length2 + 1];
    
    
    // the maximum levenshtein distance is going to be the length of the longer charm
    for(int i = 0; i <= length1; i++)
    {
        distance[i] = i;
    }
    
    int i = 0;
    //  calculates the levenshtein distance between the strings
    // by first iterating through the first string
    for(string::const_iterator iter1 = charm1.begin(); iter1 != charm1.end(); iter1++, i++)
    {
        distance[0] = i + 1;
        int end = i;
        int k = 0;
        //then iterating through the second string
        for(string::const_iterator iter2 = charm2.begin(); iter2 != charm2.end(); iter2++, k++)
        {
            int top = distance[k + 1];
            // if two characters are equal
            if(*iter1 == *iter2)
            {
                distance[k + 1] = end;
            }else
            {
                int t(top < end ? top:end);
                distance[k + 1] = (distance[k] < t ? distance[k]:t) + 1;
            }
            
            end = top;
        }
    }
    return distance[length2];
}

//gets min distance to adjacent realms
int minVertDist(int lvsDist[], bool flag[], vector<string> charms)
{
    int min = infinity, mIndex = 0;
    long numVert = charms.size();
    
    for (int v = 0; v < numVert; v++)
    {
        if (flag[v] == false && lvsDist[v] <= min)
        {
            min = lvsDist[v];
            mIndex = v;
        }
    }
    return mIndex;
}

//checks if travel is possible from starting realm to end realm under constraints of problem
//prints
void canTravel(string charm1, string charm2, vector<string> charms, unordered_map<string, vector<int>> realm, int N)
{
    int graph[N][N];
    int tempIncant;
    
    for(int i = 0; i < N; i++)
    {
        long rowMax = realm.find(charms.at(i))->second.size();
        
        for(int k = 0; k < N; k++)
        {
            if(i == k)
            {
                graph[i][k] = 0;
            }else
            {
                tempIncant = incantations(charms.at(i), charms.at(k));
                
                if(rowMax < tempIncant)
                {
                    tempIncant = 0;
                }
                
                graph[i][k] = tempIncant;
            }
        }
    }
    
    long numVert = charms.size();
    int lvsDist[numVert];
    int gems[numVert];
    bool flag[numVert];
    
    for (int i = 0; i < numVert; i++)
    {
        lvsDist[i] = infinity, flag[i] = false;
        gems[i] = 0;
    }
    
    long src = find(charms.begin(), charms.end(), charm1) - charms.begin();
    
    lvsDist[src] = 0;
    
    for (int count = 0; count < numVert-1; count++)
    {
        int u = minVertDist(lvsDist, flag, charms);
        flag[u] = true;
        
        for(int v = 0; v < numVert; v++)
        {
            if (!flag[v] && graph[u][v] && lvsDist[u] != infinity && lvsDist[u]+graph[u][v] < lvsDist[v])
            {
                lvsDist[v] = lvsDist[u] + graph[u][v];
                int weight = graph[u][v];
                vector<int>tempGem = realm.find(charms.at(u))->second;
                int sum = 0;
                
                for(int i = 0; i < weight; i++)
                {
                    sum += tempGem.at(i);
                }
                
                gems[v] = gems[u] + sum;
            }
        }
        
    }
    
    
    long src1 = find(charms.begin(), charms.end(), charm2) - charms.begin();
    if (gems[src1] == 0 && lvsDist[src1] != 0)
    {
        cout << "IMPOSSIBLE" << endl;
    }
    else
    {
        cout << lvsDist[src1] << " " << gems[src1] <<endl;
    }
    
    usleep(1);
}

vector<int> seq(vector<int>array)
{
    long length = array.size();
    vector<int> temp1;
    vector<int> seqMax;
    long seqMaxLength = 0;
    
    for(int i = 0; i < length; i++)
    {
        for(int k = i; k < length; k++)
        {
            if(k == i)
            {
                temp1.push_back(array.at(k));
            }else if(temp1.back() < array.at(k))
            {
                temp1.push_back(array.at(k));
            }
        }
        if(temp1.size() > seqMax.size())
        {
            seqMaxLength = temp1.size();
            seqMax = temp1;
        }
        temp1.clear();
    }
    
    return seqMax;
}

int main()
{
    int N, magiNum;
    string charm, start, end;
    vector<string> charms;
    vector<int> magis;
    unordered_map<string, vector<int>> realm;
    
    cin>>N;
    
    for(int i = 0; i < N; i++)
    {
        cin>>charm;
        charms.push_back(charm);
        cin>>magiNum;
        magis.resize(magiNum);
        
        for(int j = 0; j < magiNum; j++)
        {
            cin>>magis.at(j);
        }
        
        realm.emplace(charm, seq(magis));
    }
    
    cin>>start;
    cin>>end;
    
    canTravel(start, end, charms, realm, N);
    canTravel(end, start, charms, realm, N);
    
    return 0;
}
